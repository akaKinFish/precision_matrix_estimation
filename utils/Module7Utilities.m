classdef Module7Utilities < handle
    % MODULE7UTILITIES - Enhanced class with complex Hermitian matrix support
    %
    % This class contains static methods for analyzing both real and complex
    % simulation data generated by module7_simulation functions.
    %
    % Usage:
    %   stats = Module7Utilities.analyze_simulation_quality_complex(...);
    %   kl_div = Module7Utilities.compute_complex_kl_divergence(...);
    
    methods (Static)
        
        % Original real-valued analysis method
        function stats = analyze_simulation_quality(true_precision, true_covariance, emp_covariance, params)
            % ANALYZE_SIMULATION_QUALITY - Original method for real matrices
            % (Keep all existing functionality - copy from your existing implementation)
            
            stats = struct();
            n_freq = params.n_freq;
            n_nodes = params.n_nodes;
            
            % 1. Covariance estimation errors
            stats.cov_errors = struct();
            rel_errors = zeros(n_freq, 1);
            abs_errors = zeros(n_freq, 1);
            
            for f = 1:n_freq
                diff = emp_covariance{f} - true_covariance{f};
                rel_errors(f) = norm(diff, 'fro') / norm(true_covariance{f}, 'fro');
                abs_errors(f) = norm(diff, 'fro');
            end
            
            stats.cov_errors.relative_mean = mean(rel_errors);
            stats.cov_errors.relative_std = std(rel_errors);
            stats.cov_errors.absolute_mean = mean(abs_errors);
            stats.cov_errors.absolute_std = std(abs_errors);
            
            % Add other existing functionality here...
            fprintf('\n=== Basic Simulation Quality Analysis ===\n');
            fprintf('Mean relative error: %.4f ± %.4f\n', ...
                    stats.cov_errors.relative_mean, stats.cov_errors.relative_std);
            fprintf('========================================\n');
        end
        
        % Enhanced complex-valued analysis method
        function stats = analyze_simulation_quality_complex(true_precision, true_covariance, emp_covariance, params)
            % ANALYZE_SIMULATION_QUALITY_COMPLEX - Enhanced for complex Hermitian matrices
            
            stats = struct();
            n_freq = params.n_freq;
            n_nodes = params.n_nodes;
            
            fprintf('\n=== Complex Hermitian Matrix Analysis ===\n');
            
            % 1. Verify Hermitian properties
            hermitian_check = struct();
            hermitian_check.precision_hermitian = zeros(n_freq, 1);
            hermitian_check.covariance_hermitian = zeros(n_freq, 1);  
            hermitian_check.empirical_hermitian = zeros(n_freq, 1);
            
            for f = 1:n_freq
                hermitian_check.precision_hermitian(f) = ishermitian(true_precision{f});
                hermitian_check.covariance_hermitian(f) = ishermitian(true_covariance{f});
                hermitian_check.empirical_hermitian(f) = ishermitian(emp_covariance{f});
            end
            
            stats.hermitian_check = hermitian_check;
            
            fprintf('Hermitian Property Verification:\n');
            fprintf('  Precision matrices: %d/%d Hermitian\n', ...
                    sum(hermitian_check.precision_hermitian), n_freq);
            fprintf('  True covariance matrices: %d/%d Hermitian\n', ...
                    sum(hermitian_check.covariance_hermitian), n_freq);
            fprintf('  Empirical covariance matrices: %d/%d Hermitian\n', ...
                    sum(hermitian_check.empirical_hermitian), n_freq);
            
            % 2. Complex covariance estimation errors
            stats.cov_errors = struct();
            rel_errors = zeros(n_freq, 1);
            abs_errors = zeros(n_freq, 1);
            phase_errors = zeros(n_freq, 1);
            
            for f = 1:n_freq
                diff = emp_covariance{f} - true_covariance{f};
                rel_errors(f) = norm(diff, 'fro') / norm(true_covariance{f}, 'fro');
                abs_errors(f) = norm(diff, 'fro');
                
                % Phase error analysis
                true_angle = angle(true_covariance{f});
                emp_angle = angle(emp_covariance{f});
                mask = ~eye(n_nodes);
                phase_diff = abs(true_angle(mask) - emp_angle(mask));
                phase_diff = min(phase_diff, 2*pi - phase_diff);
                phase_errors(f) = mean(phase_diff);
            end
            
            stats.cov_errors.relative_mean = mean(rel_errors);
            stats.cov_errors.relative_std = std(rel_errors);
            stats.cov_errors.absolute_mean = mean(abs_errors);
            stats.cov_errors.absolute_std = std(abs_errors);
            stats.cov_errors.phase_error_mean = mean(phase_errors);
            stats.cov_errors.phase_error_std = std(phase_errors);
            
            % 3. Positive definiteness check
            stats.positive_definite = struct();
            min_eigval_prec = inf;
            min_eigval_cov = inf;
            min_eigval_emp = inf;
            max_imag_eigval = 0;
            
            for f = 1:n_freq
                eigvals_prec = eig(true_precision{f});
                eigvals_cov = eig(true_covariance{f});
                eigvals_emp = eig(emp_covariance{f});
                
                min_eigval_prec = min(min_eigval_prec, min(real(eigvals_prec)));
                min_eigval_cov = min(min_eigval_cov, min(real(eigvals_cov)));
                min_eigval_emp = min(min_eigval_emp, min(real(eigvals_emp)));
                
                max_imag_eigval = max(max_imag_eigval, max(abs(imag([eigvals_prec; eigvals_cov; eigvals_emp]))));
            end
            
            stats.positive_definite.min_eigenvalue_precision = min_eigval_prec;
            stats.positive_definite.min_eigenvalue_covariance = min_eigval_cov;
            stats.positive_definite.min_eigenvalue_empirical = min_eigval_emp;
            stats.positive_definite.max_imaginary_eigenvalue = max_imag_eigval;
            
            % Print summary
            fprintf('Complex Matrix Quality Summary:\n');
            fprintf('  Mean relative error: %.4f ± %.4f\n', ...
                    stats.cov_errors.relative_mean, stats.cov_errors.relative_std);
            fprintf('  Mean phase error: %.4f ± %.4f radians\n', ...
                    stats.cov_errors.phase_error_mean, stats.cov_errors.phase_error_std);
            fprintf('  Min eigenvalue: %.6f\n', stats.positive_definite.min_eigenvalue_precision);
            fprintf('  Max imaginary eigenvalue: %.2e\n', stats.positive_definite.max_imaginary_eigenvalue);
            fprintf('==========================================\n');
        end
        
        function kl_div = compute_complex_kl_divergence(Sigma1, Sigma2)
            % COMPUTE_COMPLEX_KL_DIVERGENCE - KL divergence for complex multivariate normal
            %
            % For complex multivariate normal distributions:
            % KL(N1||N2) = 0.5 * [trace(Sigma2^{-1} * Sigma1) - k + log(det(Sigma2)/det(Sigma1))]
            
            n = size(Sigma1, 1);
            
            % Compute determinants
            det1 = det(Sigma1);
            det2 = det(Sigma2);
            
            % Check for positive determinants
            if real(det1) <= 0 || real(det2) <= 0
                warning('Module7Utilities:NonPositiveDeterminants', ...
                        'Non-positive determinants detected in KL divergence calculation');
                kl_div = Inf;
                return;
            end
            
            % Compute KL divergence
            try
                inv_Sigma2 = inv(Sigma2);
                trace_term = trace(inv_Sigma2 * Sigma1);
                log_term = log(det2 / det1);
                
                kl_div = 0.5 * real(trace_term - n + log_term);
            catch ME
                warning(ME.identifier, 'Error computing KL divergence: %s', ME.message);
                kl_div = Inf;
            end
        end
        
        function [W, success] = sample_complex_wishart(n, Sigma, method)
            % SAMPLE_COMPLEX_WISHART - Generate complex Wishart matrix
            %
            % Inputs:
            %   n - degrees of freedom (should be >= size(Sigma,1))
            %   Sigma - complex Hermitian positive definite scale matrix
            %   method - 'direct' (default) or 'bartlett'
            %
            % Output:
            %   W - complex Wishart sample W ~ CW_p(n, Sigma)
            %   success - boolean indicating successful generation
            
            if nargin < 3
                method = 'direct';
            end
            
            p = size(Sigma, 1);
            success = true;
            
            try
                switch lower(method)
                    case 'direct'
                        % Direct sampling via multivariate complex normal
                        Z = complex(zeros(p, n));
                        
                        % Cholesky decomposition
                        L = chol(Sigma, 'lower');
                        
                        for i = 1:n
                            % Generate complex standard normal
                            real_part = randn(p, 1);
                            imag_part = randn(p, 1);
                            z_std = complex(real_part, imag_part) / sqrt(2);
                            
                            % Transform to have covariance Sigma
                            Z(:, i) = L * z_std;
                        end
                        
                        % Form Wishart sample
                        W = Z * Z';
                        
                    otherwise
                        error('Unknown method: %s', method);
                end
                
                % Ensure Hermitian property
                W = (W + W') / 2;
                
                % Verify positive definiteness
                eigvals = eig(W);
                if any(real(eigvals) <= 0)
                    warning('Module7Utilities:NotPositiveDefinite', ...
                            'Generated matrix is not positive definite');
                    success = false;
                end
                
            catch ME
                warning(ME.identifier, 'Error in complex Wishart sampling: %s', ME.message);
                W = eye(p);
                success = false;
            end
        end
        
        function is_valid = validate_complex_hermitian_matrix(A, tolerance)
            % VALIDATE_COMPLEX_HERMITIAN_MATRIX - Check if matrix is properly Hermitian
            
            if nargin < 2
                tolerance = 1e-10;
            end
            
            is_valid = true;
            
            % Check if matrix is square
            [m, n] = size(A);
            if m ~= n
                is_valid = false;
                return;
            end
            
            % Check Hermitian property manually with tolerance
            hermitian_diff = A - A';
            if norm(hermitian_diff, 'fro') > tolerance
                is_valid = false;
                return;
            end
            
            % Check if diagonal elements are real
            diag_elements = diag(A);
            if any(abs(imag(diag_elements)) > tolerance)
                is_valid = false;
                return;
            end
            
            % Check positive definiteness
            eigvals = eig(A);
            if any(real(eigvals) <= tolerance)
                is_valid = false;
                return;
            end
        end
        
    end
    
end